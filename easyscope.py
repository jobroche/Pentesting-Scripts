#!/usr/bin/python

# EasyScope
# This script will take an IP address range or a list of addresses/ranges and either
# expand them into single IPs or combine them into a supernet.
#
# This script requires the netaddr library, use: "python -m pip install netaddr"
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Author:  Jonathan Broche
# Contact: @g0jhonny
# Version: 1.0
# Date:    2015-08-01
#
# example: ./easyscope -e -r 192.168.1.1 192.168.3.254 -o range_output.txt

import argparse, os, time, datetime, sys, re
from netaddr import IPNetwork, iter_iprange, cidr_merge
from itertools import count

class colors:
    lightblue = "\033[1;36m"
    lightgrey = "\033[0;37m"
    blue = "\033[1;34m"
    normal = "\033[0;00m"
    red = "\033[1;31m"
    yellow = "\033[1;33m"
    white = "\033[1;37m"
    green = "\033[1;32m"

def validate(ip):
    print "{}[*]{} Validating {}".format(colors.blue, colors.normal, ip)
    if re.match(r'^((\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])$', ip):  
        return True  
    else:
        print "{}[!]{} {} is not a valid IP address.".format(colors.red, colors.normal, ip)
        return False   

def expand_it(iplist):
    results = []
    for ip in iplist:
        if type(ip) is list: #take care of range
            [results.append(address) for address in iter_iprange(sorted(ip)[0], sorted(ip)[1])]
        else: #expand cidr
            for address in ip:
                results.append(address)
    return results

def combine_it(iplist):
    try:
        cidr_merge(iplist)
        return cidr_merge(iplist)
    except (ValueError, TypeError):
        print "{}[!]{} Ensure that all IPs are in CIDR notation.".format(colors.red, colors.normal)
 
def parse_results(results, outfile):
    print "\nResults are here! Standby...\n"
    filename = ''

    if outfile:
        print "Writing results..."
        for attempt in count(1):
            filename = os.path.join(os.getcwd(), outfile) if attempt == 1 else os.path.join(os.getcwd(), '{}{}'.format(outfile, attempt)) 
            if not os.path.exists(filename):             
                break

    for ip in results:        
        if '/' in str(ip) and str(ip).split('/', 1)[1] == '32':
            address = str(ip).split('/', 1)[0]
        else: address = ip

        if filename:
            with open(filename, 'a') as f:
                f.write('{}\n'.format(str(address)))
        else: print address

    print "\n{}[*]{} Done! Results written to {}".format(colors.blue, colors.normal, filename) if filename else "\n{}[*]{} Done!".format(colors.blue, colors.normal)

def main():
    stime = time.time()

    parser = argparse.ArgumentParser(description="EasyScope by Jonathan Broche (@g0jhonny)")
    parser.add_argument('-r', '--range', help='A set of two IP addresses', nargs=2)
    parser.add_argument('-f', '--file', help='File containing one subnet (e.g., 192.168.1.1/24) or IP range (e.g. 192.168.1.1-192.168.1.254) per line')
    parser.add_argument('-o', '--outfile', help='File to write results to')
    action = parser.add_mutually_exclusive_group(required=True)
    action.add_argument('-e', '--expand', action='store_true', help='Expand IP adddresses/ranges into single IP addresses')
    action.add_argument('-c', '--combine', action='store_true', help='Combine IPs addresses/ranges into supernets')    
    args = parser.parse_args()

    results, iplist = [], []

    print "\n" + "-" * 70 + "\n" + colors.white + " EasyScope v1.0 by Jonathan Broche (@g0jhonny)\n" + colors.normal + "-" * 70 + "\n"

    try:        
        if args.range or args.file:
            if args.range:
                for ip in args.range:
                    if not validate(ip.strip()):
                        return   
                    elif args.combine: 
                        iplist.append(IPNetwork(ip.strip()))
        
                if args.expand: iplist.append(args.range)
            if args.file:
                with open (args.file) as f:
                    lines = f.readlines()
                for ip in lines:
                    if '-' in ip: #if dash(range)
                        for address in ip.split('-'):
                            if not validate(address.strip()):
                                return
                        if args.combine:                            
                            [iplist.append(IPNetwork(address)) for address in expand_it([ip.strip().split('-')])]
                        else: iplist.append(ip.strip().split('-'))

                    elif '/' in ip and validate(ip.split('/', 1)[0]): #if cidr
                        iplist.append(IPNetwork(ip.strip()))
                    else:
                        if validate(ip.strip()): #if ip per line
                            iplist.append(IPNetwork(ip.strip()))
        else:
            print "{}[!]{} No scope provided, add an IP range [-r range] and/or file [-f file] to parse through\n".format(colors.red, colors.normal)
            return

        if args.expand:
            results = expand_it(iplist)
        elif args.combine:
            results = combine_it(iplist)
        else:
            print "{}[!]{} No action provided, add -c to combine IPs or -e to expand them\n".format(colors.red, colors.normal)
            return

        if args.outfile:
            parse_results(results, args.outfile)
        else:
            parse_results(results, None)
    
        print "{}[*]{} Completed in {:.2f}s\n".format(colors.green, colors.normal, time.time()- stime)   

    except Exception as e:
        print "{}[!]{} Oh Bits! There was an error: {}\n".format(colors.red, colors.normal, e)
    except IOError:
        print "{}[!]{} File: {} does not exist\n".format(colors.red, colors.normal, args.file)

if __name__ == '__main__':
    main()